### Overview of Steps:

1. **Create an EKS Cluster**
2. **Configure `kubectl` to interact with EKS**
3. **Install Helm on your local machine**
4. **Create a Helm Chart for the Spring Boot application**
5. **Deploy the Spring Boot application to EKS**
6. **Configure Kubernetes to run only two instances of the Spring Boot service**
7. **Expose the service through a load balancer**

---

### **Step 1: Create an EKS Cluster**

Before deploying anything to EKS, you need to create a cluster. You can do this using the AWS Management Console or the AWS CLI.

#### Using AWS CLI:
1. **Install AWS CLI and configure it** if you haven't done so already:
   ```bash
   aws configure
   ```

2. **Create the EKS Cluster:**

   For this example, let's create a basic EKS cluster. We'll use `eksctl`, a command-line tool for creating and managing EKS clusters.

   Install `eksctl` if you don't have it:
   ```bash
   brew install eksctl  # on macOS
   ```

   Now, create a cluster:

   ```bash
   eksctl create cluster \
     --name springboot-cluster \
     --region us-west-2 \
     --nodes 2 \
     --nodes-min 2 \
     --nodes-max 2 \
     --node-type t3.medium
   ```

   This creates a 2-node EKS cluster. Adjust the region and instance types as needed.

---

### **Step 2: Configure `kubectl` to Interact with EKS**

After your cluster is created, configure `kubectl` to use the newly created EKS cluster.

```bash
aws eks --region us-west-2 update-kubeconfig --name springboot-cluster
```

This configures your local `kubectl` to interact with the EKS cluster.

---

### **Step 3: Install Helm**

If you haven't installed Helm yet, do so now.

```bash
brew install helm  # macOS
```

Once Helm is installed, make sure it's working by running:

```bash
helm version
```

---

### **Step 4: Create a Helm Chart for the Spring Boot Application**

Youâ€™ll need to create a Helm chart for deploying your Spring Boot application.

1. **Create a New Helm Chart:**

   First, create a Helm chart to package your Spring Boot application:

   ```bash
   helm create springboot-app
   ```

   This will generate a chart structure under the `springboot-app/` directory.

2. **Modify Chart Files:**

   You'll need to adjust some of the default files generated by Helm to meet your requirements.

   - **`values.yaml`**: Define the number of replicas (2) and customize the port.

     Update the `values.yaml` to expose your Spring Boot application on port `8089`.

     ```yaml
     replicaCount: 2

     image:
       repository: your-docker-repo/springboot-app
       tag: latest

     service:
       type: LoadBalancer
       port: 8089

     ingress:
       enabled: false  # We'll use the LoadBalancer instead of ingress
     ```

   - **`deployment.yaml`**: Ensure that the application is configured to expose port 8089.

     The generated `deployment.yaml` should look like this (with the necessary adjustments):

     ```yaml
     apiVersion: apps/v1
     kind: Deployment
     metadata:
       name: {{ include "springboot-app.name" . }}
       labels:
         {{- include "springboot-app.labels" . | nindent 4 }}
     spec:
       replicas: {{ .Values.replicaCount }}
       selector:
         matchLabels:
           app: {{ include "springboot-app.name" . }}
       template:
         metadata:
           labels:
             app: {{ include "springboot-app.name" . }}
         spec:
           containers:
             - name: {{ .Chart.Name }}
               image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
               ports:
                 - name: http
                   containerPort: 8089
     ```

   - **`service.yaml`**: This defines a Kubernetes `Service` of type `LoadBalancer`.

     Make sure that the `service.yaml` reflects a public LoadBalancer service on port 8089:

     ```yaml
     apiVersion: v1
     kind: Service
     metadata:
       name: {{ include "springboot-app.name" . }}
       labels:
         {{- include "springboot-app.labels" . | nindent 4 }}
     spec:
       type: LoadBalancer
       ports:
         - port: 8089
           targetPort: 8089
       selector:
         app: {{ include "springboot-app.name" . }}
     ```

---

### **Step 5: Deploy the Spring Boot Application**

Once your Helm chart is ready, you can deploy it to EKS.

1. **Install the Chart:**

   First, package your Helm chart and install it into the Kubernetes cluster:

   ```bash
   helm install springboot-release ./springboot-app
   ```

   This will deploy the Spring Boot application with two replicas and a public LoadBalancer.

---

### **Step 6: Verify the Deployment**

1. **Check the status of your pods:**

   After deploying, verify that the pods are running:

   ```bash
   kubectl get pods
   ```

   You should see two pods corresponding to your Spring Boot application.

2. **Check the Service:**

   Now, check the status of the LoadBalancer:

   ```bash
   kubectl get svc
   ```

   The `EXTERNAL-IP` column will show the public IP of your LoadBalancer. Once the LoadBalancer is provisioned, you can access your Spring Boot application at this IP on port `8089`.

   Example output:

   ```
   NAME                TYPE           CLUSTER-IP      EXTERNAL-IP       PORT(S)          AGE
   springboot-release   LoadBalancer   10.100.200.1    a12b34c56d78.elb.us-west-2.amazonaws.com   8089:31982/TCP   1m
   ```

   Here, the public IP is `a12b34c56d78.elb.us-west-2.amazonaws.com`, and your application is accessible at `http://a12b34c56d78.elb.us-west-2.amazonaws.com:8089`.

---

### **Step 7: Scale the Application (Optional)**

If you want to change the number of instances of your application, you can scale the deployment:

```bash
kubectl scale deployment springboot-release --replicas=2
```

This ensures that only 2 instances of your application are running.

---

### **Step 8: Clean Up (Optional)**

If you're done and want to delete the resources (including the EKS cluster):

```bash
helm uninstall springboot-release
eksctl delete cluster --name springboot-cluster
```

---

### Summary

To meet your requirements:
- You created an **EKS cluster** using `eksctl`.
- You used **Helm** to deploy a **Spring Boot application** with 2 replicas.
- You exposed the service via a **public LoadBalancer** on port `8089`.

This setup provides a scalable, highly available deployment of your Spring Boot application on EKS. If you need further adjustments, feel free to ask!